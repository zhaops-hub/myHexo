---
title:  浮点数转换二进制
date: 2020-05-28 20:41:08
categories: C语言
tags:
- C语言
top: 105

copyright: ture

---
## 浮点数在计算机中是如何表示的？

浮点数在计算机中的存储方式遵循IEEE 754 浮点数计数标准，可以表示为：

![](c_float/1.png)

采用**尾数 + 阶码**的编码方式，更通俗一点说，就是类似于数学课本上所学的**科学计数法**表示方式：**有效数字 + 指数位**！

因此，只要给出：**符号（S）**、**阶码部分（E）**、**尾数部分（M）** 这三个维度的信息，一个浮点数的表示就完全确定下来了，所以`float`和`double`这两种类型的浮点数在计算机中的存储结构就表示成下图所示这个样子：



![](c_float/2.png)



- **符号部分（S）**

  `0`-正 `1`-负

- **阶码部分（E）（指数部分）**

  对于`float`型浮点数，指数部分`8`位，考虑可正可负，因此可以表示的指数范围为`-127 ~ 128`

  对于`double`型浮点数，指数部分`11`位，考虑可正可负，因此可以表示的指数范围为`-1023 ~ 1024`

- **尾数部分（M）**

  浮点数的精度是由尾数的位数来决定的：

  - 对于`float`型浮点数，尾数部分`23`位，换算成十进制就是 `2^23=8388608`，所以十进制精度只有`6 ~ 7`位；
  - 对于`double`型浮点数，尾数部分`52`位，换算成十进制就是 `2^52 = 4503599627370496`，所以十进制精度只有`15 ~ 16`位

以，浮点数交给计算机存储的时候，可能会有**精度丢失**问题！！！因此使用时需要格外小心，如果真因为这一块出了bug，定位问题还是非常艰难的，所以预防工作要做好。

## 先来个简单的例子

比如：**把十进制小数`0.875`转换成二进制，具体怎么操作？**

- **以小数点为界，拆分**

- **整数部分转换**

  整数转二进制我想大家应该都熟悉，使用：**除2取余法** 即可。而这里的`0.875`整数部分为0，无需操作

- **小数部分转换**

  小数部分的转换不同于整数部分，采用的是 **“乘2取整法”** ，图示一下就明白了

  ![](c_float/3.png)

- **合并结果**

  `整数部分 + 小数部分`，最终得到二进制结果为`0.111`。

  

  

  所以该结果按照上一节所述的**尾数 + 阶码**的计算机计数方式，则可以表示为：

  ![](c_float/4.png)

  

  **0.111 = 1.11*2^-1**  类似于科学计数法

  

  所以对应可得：

  - **符号位**：`0`
  - **阶码（E）部分**：若以`float`为例，应为 `127 +（-1）= 126`，因此二进制表示为：`01111110`
  - **尾数部分（M）**：若以`float`为例，应为`23`位，因此尾部补齐后为`11000000000000000000000`

因此最终的总结果为（以`32`位精度`float`表示）：

`00111111011000000000000000000000`

## 再来个复杂点例子

再比如：**把十进制小数`6.36`转换成二进制，具体怎么操作？**

![](c_float/5.png)



整数部分 + 小数部分，因此最终得到的结果二进制结果为`110.01011100...`。

还是按照上一节所述的**尾数 + 阶码**的计算机计数方式，则可以表示为：

![](c_float/6.png)



- **符号位**：0
- **阶码（E）部分**：若以`float`为例，应为 `127 +（2）= 129`，因此二进制表示为：`10000001`
- **尾数部分（M）**：`1001011100...`，其实它本身无限不循环，但若以`float`型精度来截取`23`位，则可以表示为`10010111000010100011111`

因此最终的总结果为（以`32`位精度`float`表示）：

`01000000110010111000010100011111`